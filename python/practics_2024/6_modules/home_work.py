'''Вы работаете над разработкой программы для проверки корректности даты, введенной пользователем.
 На вход будет подаваться дата в формате "день.месяц.год". Ваша задача - создать программу, которая проверяет,
является ли введенная дата корректной или нет. Ваша программа должна предоставить ответ "True" (дата корректна)
 или "False" (дата некорректна) в зависимости от результата проверки.
Пример использования На входе:date_to_prove = 15.4.2023 На выходе: True
На входе: date_to_prove = 31.6.2022 На выходе: False
'''
import sys


# def leap_year(year: int) -> bool:
#     return bool(not year%4 and year%100 or not year%400)
#
#
# def check_date(user_date: list[str]) -> bool:
#     monthes = [31, (28, 29), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
#
#     day, month, year = list(map(int, user_date))
#     if 0 < year <9999:
#         if month ==2:
#             # monthes[month-1][1] -> [month-1] = 2 -1 первый элемент в списке monthes = (28, 29), [1]=29
#             return bool(0 < day <= (monthes[month-1][1] if leap_year(year) else monthes[month-1][0]))
#         else:
#             if 0 < month < 13:
#                 return 0 < day <= monthes[month-1]
#
#
# print(check_date(input(list('Введите дату: ').replace('.', ''))))

# if __name__ == '__main__':
#     date = sys.argv[-1].split('.')
#     print(check_date(date))

# !!! Корректный вариант
# def _is_leap(current_year: int) -> bool:
#     return not current_year % 4 and current_year % 100 or not current_year % 400
#
#
# def date_validate(user_date: str) -> bool:
#     day, month, year = map(int, user_date.split('.'))
#     _months = {i: 30 if i in (4, 6, 9, 11) else 31 for i in range(1, 13)}
#     _months[2] = 29 if _is_leap(year) else 28
#
#     if 0 < year < 10000 and month in _months and 0 < day <= _months[month]:
#         return True
#     return False
#
#
# if __name__ == '__main__':
#     print(date_validate('29.02.2024'))
#     print(date_validate('29.02.2023'))
#     print(date_validate('29.13.2024'))
#     print(date_validate('29.02.20245'))

'''Расстановка ферзей
Используйте генератор случайных чисел для случайной расстановки ферзей в задаче выше. Проверяйте различный случайные варианты и выведите 4 успешных расстановки.
Под "успешной расстановкой ферзей" в данном контексте подразумевается такая расстановка ферзей на шахматной доске, в которой ни один ферзь не бьет другого. Другими словами, ферзи размещены таким образом, что они не находятся на одной вертикали, горизонтали или диагонали.
Список из 4х комбинаций координат сохраните в board_list. Дополнительно печатать его не надоРасстановка ферзей
Используйте генератор случайных чисел для случайной расстановки ферзей в задаче выше. Проверяйте различный случайные варианты и выведите 4 успешных расстановки.
Под "успешной расстановкой ферзей" в данном контексте подразумевается такая расстановка ферзей на шахматной доске, в которой ни один ферзь не бьет другого. Другими словами, ферзи размещены таким образом, что они не находятся на одной вертикали, горизонтали или диагонали.
Список из 4х комбинаций координат сохраните в board_list. Дополнительно печатать его не надо'''

# # !!!! Зацикливание, смотрим только алгоритм
# import random
#
#
# board_list = [] # список для успешной расстановки
#
# while len(board_list) <4: # выполняем 4 раза для каждой успешной расстановки
#     board = [] # текущая расстановка
#
#     while len(board) < 8:
#         x = random.randint(0,7) #случайная координата по оси X
#         y = random.randint(0, 7)  # случайная координата по оси Y
#
#         #проверка, что координаты не совпадают с уже существующими,
#         # не находятся на одной вертикали, горзонтали или диагонали
#         if all(x != c[0] and y != c[1] and abs(x - c[0]) != abs(y - c[1]) for c in board):
#             board.append((x, y))  #добавляем кортеж в список
#
#     board_list.append(board)
#
#
# print(board_list)

# #РЕШЕНИЕ с гитхаба
# import random
#
# def validate_queens(positions):
#     for i in range(8):
#         for j in range(i+1, 8):
#             # проверка на наличие на одной строке или диагонали
#             if positions[i] == positions[j] or \
#                 positions[i] - i == positions[j] - j or \
#                 positions[i] + i == positions[j] + j:
#                 return False
#     return True
#
# def generate_positions():
#     positions = list(range(1, 9))  # создаём список с числами от 1 до 8
#     for i in range(4):  # 4 успешные расстановки
#         random.shuffle(positions)  # перемешиваем список
#         while not validate_queens(positions):  # если расстановка не успешная, перемешиваем ещё раз
#             random.shuffle(positions)
#         print(positions)  # выводим успешную расстановку
#
#
# generate_positions()

#РЕШЕНИЕ с сайта гиков
import random
from itertools import combinations

def generate_board():
    # Генерируем случайную доску
    board = []

    for i in range(1, 8+1):
        queen = (i, random.randint(1, 8))
        board.append(queen)
    return board
# [(1, 1), (2, 6), (3, 2), (4, 3), (5, 1), (6, 8), (7, 3), (8, 2)]

def is_attacking(q1, q2): # q1 - это пара кортежей (пара ферзей) = ((1, 1), (2, 6)) / q2 = ((1, 1), (3, 2))
    # Проверяем, бьют ли ферзи друг друга/
    # проверка, что координаты не совпадают с уже существующими,
    #  не находятся на одной вертикали, горзонтали или диагонали
    return q1[0] == q2[0] or q1[1] == q2[1] or abs(q1[0] - q2[0]) == abs(q1[1] - q2[1])

def check_queens(queens):
    # Проверяем все возможные пары ферзей = пары кортежей
    for q1, q2 in combinations(queens, 2): # [((1, 1), (2, 6)), ((1, 1), (3, 2)), ((1, 1), (4, 3)), ((1, 1), (5, 1)), ((1, 1), (6, 8)), ((1, 1), (7, 3)), ((1, 1), (8, 2)), ((2, 6), (3, 2)), ((2, 6), (4, 3)), ((2, 6), (5, 1)), ((2, 6), (6, 8)), ((2, 6), (7, 3)), ((2, 6), (8, 2)), ((3, 2), (4, 3)), ((3, 2), (5, 1)), ((3, 2), (6, 8)), ((3, 2), (7, 3)), ((3, 2), (8, 2)), ((4, 3), (5, 1)), ((4, 3), (6, 8)), ((4, 3), (7, 3)), ((4, 3), (8, 2)), ((5, 1), (6, 8)), ((5, 1), (7, 3)), ((5, 1), (8, 2)), ((6, 8), (7, 3)), ((6, 8), (8, 2)), ((7, 3), (8, 2))]
        if is_attacking(q1, q2): # q1 - это пара кортежей (пара ферзей) = ((1, 1), (2, 6))
            return False
    return True

def generate_boards():
    # Генерируем доски, пока не получим 4 успешные расстановки
    count = 0
    board_list = []
    while count < 4:
        board = generate_board()
        if check_queens(board):
            count += 1
            board_list.append(board)
    return board_list


print(generate_boards())

'''функцию is_attacking(q1,q2), проверяющую, бьют ли ферзи друг друга и check_queens(queens), которая проверяет все возможные пары ферзей.
Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга.
Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей. Если ферзи не бьют друг друга верните истину, а если бьют - ложь. Не забудьте напечатать результат.

Пример использования.
На входе:


queens = [(1, 1), (2, 3), (3, 5), (4, 7), (5, 2), (6, 4), (7, 6), (8, 8)] 
На выходе:


False'''

queens = [(1, 1), (2, 3), (3, 5), (4, 7), (5, 2), (6, 4), (7, 6), (8, 8)]


from itertools import combinations

def is_attacking(q1, q2):
    # Проверяем, бьют ли ферзи друг друга/
    # проверка, что координаты не совпадают с уже существующими,
    #  не находятся на одной вертикали, горзонтали или диагонали
    return q1[0] == q2[0] or q1[1] == q2[1] or abs(q1[0] - q2[0]) == abs(q1[1] - q2[1])

def check_queens(queens):
    # Проверяем все возможные пары ферзей
    for q1, q2 in combinations(queens, 2): # [((1, 1), (2, 6)), ((1, 1), (3, 2)), ((1, 1), (4, 3)), ((1, 1), (5, 1)), ((1, 1), (6, 8)), ((1, 1), (7, 3)), ((1, 1), (8, 2)), ((2, 6), (3, 2)), ((2, 6), (4, 3)), ((2, 6), (5, 1)), ((2, 6), (6, 8)), ((2, 6), (7, 3)), ((2, 6), (8, 2)), ((3, 2), (4, 3)), ((3, 2), (5, 1)), ((3, 2), (6, 8)), ((3, 2), (7, 3)), ((3, 2), (8, 2)), ((4, 3), (5, 1)), ((4, 3), (6, 8)), ((4, 3), (7, 3)), ((4, 3), (8, 2)), ((5, 1), (6, 8)), ((5, 1), (7, 3)), ((5, 1), (8, 2)), ((6, 8), (7, 3)), ((6, 8), (8, 2)), ((7, 3), (8, 2))]
        if is_attacking(q1, q2):
            return False
    return True






